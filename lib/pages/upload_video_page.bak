import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:firebase_database/firebase_database.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:twitter_api_v2/twitter_api_v2.dart' as v2;
import 'package:provider/provider.dart';
import 'package:path_provider/path_provider.dart';
import 'package:intl/intl.dart';
import 'package:intl/date_symbol_data_local.dart';
import '../providers/theme_provider.dart';
import './scheduled_posts_page.dart';
import './upload_confirmation_page.dart';
import './schedule_post_page.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'dart:async';
import 'package:video_player/video_player.dart';

// Enum per lo stato di upload
enum UploadState { notStarted, uploading, completed, error }

// Classe per tracciare lo stato di upload
class UploadStatus {
  final String platform;
  final String accountId;
  UploadState state;
  String? error;
  double progress;

  UploadStatus({
    required this.platform,
    required this.accountId,
    this.state = UploadState.notStarted,
    this.error,
    this.progress = 0.0,
  });
}

class UploadVideoPage extends StatefulWidget {
  final Map<String, dynamic>? draftData;

  const UploadVideoPage({
    super.key,
    this.draftData,
  });

  @override
  State<UploadVideoPage> createState() => _UploadVideoPageState();
}

class _UploadVideoPageState extends State<UploadVideoPage> {
  final ImagePicker _picker = ImagePicker();
  File? _videoFile;
  bool _isImageFile = false;
  String? _thumbnailPath;
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _promptController = TextEditingController();
  final Map<String, List<String>> _selectedAccounts = {};
  final Map<String, String> _instagramContentType = {};
  String? _pressedButton; // Per tenere traccia del pulsante premuto
  bool _isUploading = false;
  bool _isGeneratingDescription = false;
  bool _useChatGPT = false;
  bool _showCheckmark = false;
  DateTime? _scheduledDateTime;
  bool _isScheduled = false;
  final DatabaseReference _database = FirebaseDatabase.instance.ref();
  final ScrollController _scrollController = ScrollController();
  double _scrollPosition = 0.0;
  
  // Controller per la riproduzione del video
  VideoPlayerController? _videoPlayerController;
  bool _isVideoInitialized = false;

  final List<Color> _gradientColors = [
    const Color(0xFF6C63FF),
    const Color(0xFF4A45B1),
    const Color(0xFFFF6B6B),
    const Color(0xFFEE0979),
    const Color(0xFF00C9FF),
    const Color(0xFF92FE9D),
  ];
  Map<String, List<Map<String, dynamic>>> _socialAccounts = {
    'TikTok': [
      {
        'username': '@dance_vibes',
        'avatar': 'https://example.com/avatar1.jpg',
        'followers': '10.2K'
      },
      {
        'username': '@travel_moments',
        'avatar': 'https://example.com/avatar2.jpg',
        'followers': '5.8K'
      }
    ],
    'YouTube': [
      {
        'username': 'Travel & Adventures',
        'avatar': 'https://example.com/avatar3.jpg',
        'subscribers': '25.6K'
      }
    ],
    'Instagram': [],
    'Facebook': [],
    'Twitter': [],
    'Threads': [],
  };

  final Map<String, String> _platformLogos = {
    'TikTok': 'assets/loghi/logo_tiktok.png',
    'YouTube': 'assets/loghi/logo_yt.png',
    'Instagram': 'assets/loghi/logo_insta.png',
    'Facebook': 'assets/loghi/logo_facebook.png',
    'Twitter': 'assets/loghi/logo_twitter.png',
    'Threads': 'assets/loghi/threads_logo.png',
  };

  final Map<String, IconData> _platformIcons = {
    'TikTok': Icons.music_note,
    'YouTube': Icons.play_arrow,
    'Instagram': Icons.camera_alt,
    'Facebook': Icons.facebook,
    'Twitter': Icons.chat,
    'Threads': Icons.chat,
  };

  // ChatGPT Configuration
  static const String _apiKey = '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';
  static const int _maxTokens = 150;

  Map<String, UploadStatus> _uploadStatuses = {};
  bool _showStickyButton = false;
  bool _isMenuExpanded = false;
  Timer? _scrollDebounceTimer;
  double _lastScrollPosition = 0.0;
  final Map<String, bool> _usePlatformSpecificContent = {};
  final Map<String, TextEditingController> _platformTitleControllers = {};
  final Map<String, TextEditingController> _platformDescriptionControllers = {};
  final Map<String, int> _platformDescriptionLengths = {};
  final Map<String, bool> _useChatGPTforPlatform = {};
  final Map<String, TextEditingController> _platformPromptControllers = {};

  // Limiti di caratteri per le descrizioni delle varie piattaforme
  final Map<String, int> _platformDescriptionLimits = {
    'TikTok': 2200,  // Già corretto a 2200
    'YouTube': 5000,
    'Instagram': 2200,
    'Facebook': 8000,
    'Twitter': 280,
    'Threads': 500,
  };

  // Limiti per la generazione con ChatGPT per ogni piattaforma
  final Map<String, int> _platformChatGPTLimits = {
    'TikTok': 500,
    'YouTube': 500,
    'Instagram': 500,
    'Facebook': 500,
    'Twitter': 250,  // Limite più basso per Twitter
    'Threads': 400,
  };

  // Add a field to track user credits
  int _userCredits = 750; // Default value, will be loaded from database

  @override
  void initState() {
    super.initState();
    initializeDateFormatting('it_IT', null);
    _scrollController.addListener(_onScroll);
    _loadSocialAccounts();
    _loadUserCredits(); // Add method to load user credits
    
    // Initialize platform-specific content flags (default to true = use global content)
    _socialAccounts.keys.forEach((platform) {
      _usePlatformSpecificContent[platform] = true;
      _platformTitleControllers[platform] = TextEditingController();
      _platformDescriptionControllers[platform] = TextEditingController();
      _platformPromptControllers[platform] = TextEditingController();
      _platformDescriptionLengths[platform] = 0;
      _useChatGPTforPlatform[platform] = false;
      
      // Aggiungi listener per monitorare la lunghezza della descrizione
      _platformDescriptionControllers[platform]!.addListener(() {
        setState(() {
          _platformDescriptionLengths[platform] = _platformDescriptionControllers[platform]!.text.length;
        });
      });
    });
    
    // Add listener to the main description controller
    _descriptionController.addListener(() {
      // Update description lengths for platforms using global content
      setState(() {
        _socialAccounts.keys.forEach((platform) {
          if (_usePlatformSpecificContent[platform] == true) {
            _platformDescriptionLengths[platform] = _descriptionController.text.length;
          }
        });
      });
    });
    
    // Load draft data if available
    if (widget.draftData != null) {
      _loadDraftData();
    }
  }

  // Add method to load user credits
  Future<void> _loadUserCredits() async {
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) return;

      final creditsSnapshot = await _database
          .child('users')
          .child('users')
          .child(currentUser.uid)
          .child('credits')
          .get();

      if (creditsSnapshot.exists && mounted) {
        setState(() {
          _userCredits = (creditsSnapshot.value as int?) ?? 750;
        });
      }
    } catch (e) {
      print('Error loading user credits: $e');
    }
  }

  void _loadDraftData() {
    final draft = widget.draftData!;
    
    // Set video file
    if (draft['video_path'] != null) {
      final videoPath = draft['video_path'] as String;
      final videoFile = File(videoPath);
      
      // Check if file exists
      if (videoFile.existsSync()) {
        setState(() {
          _videoFile = videoFile;
          _showCheckmark = true;
          _isImageFile = videoPath.toLowerCase().endsWith('.jpg') || 
                       videoPath.toLowerCase().endsWith('.jpeg') || 
                       videoPath.toLowerCase().endsWith('.png');
        });
        
        // Initialize video player if it's a video
        if (!_isImageFile) {
          _initializeVideoPlayer(videoFile);
        }
      } else {
        // Try to find the file in the app's local storage
        final fileName = videoPath.split('/').last;
        getApplicationDocumentsDirectory().then((directory) {
          final localPath = '${directory.path}/$fileName';
          final localFile = File(localPath);
          if (localFile.existsSync()) {
            setState(() {
              _videoFile = localFile;
              _showCheckmark = true;
              _isImageFile = localPath.toLowerCase().endsWith('.jpg') || 
                         localPath.toLowerCase().endsWith('.jpeg') || 
                         localPath.toLowerCase().endsWith('.png');
            });
            
            // Initialize video player if it's a video
            if (!_isImageFile) {
              _initializeVideoPlayer(localFile);
            }
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Could not find video file: $fileName'),
                backgroundColor: Colors.red,
              ),
            );
          }
        });
      }
    }
    
    // Set title and description
    _titleController.text = draft['title'] ?? '';
    _descriptionController.text = draft['description'] ?? '';
    
    // Set selected accounts with safe type casting
    try {
      final accounts = draft['accounts'];
      if (accounts != null) {
        (accounts as Map).forEach((key, value) {
          if (key is String) {
            List<String> accountList = [];
            
            if (value is List) {
              // Handle case where value is a list of maps (the expected format)
              accountList = value.map((account) {
                if (account is Map) {
                  return account['username']?.toString() ?? '';
                }
                return '';
              }).where((username) => username.isNotEmpty).toList().cast<String>();
            } else if (value is String) {
              // Handle unexpected case where value is a string
              if (value.isNotEmpty) {
                accountList = [value];
              }
            } else if (value is Map) {
              // Handle case where value is a map
              accountList = value.entries
                  .map((entry) => entry.value?.toString() ?? '')
                  .where((username) => username.isNotEmpty)
                  .toList();
            }
            
            if (accountList.isNotEmpty) {
              _selectedAccounts[key] = accountList;
            }
          }
        });
      }
      
      // Debug log the loaded accounts
      print('Loaded accounts: $_selectedAccounts');
      
    } catch (e) {
      debugPrint('Error loading accounts data: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error loading accounts data: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _toggleAccount(String platform, String accountId) {
    print('Toggling account selection: Platform=$platform, AccountID=$accountId');
    setState(() {
      if (!_selectedAccounts.containsKey(platform)) {
        _selectedAccounts[platform] = [];
      }
      
      if (_selectedAccounts[platform]!.contains(accountId)) {
        print('Removing account: $accountId from platform: $platform');
        _selectedAccounts[platform]!.remove(accountId);
        if (_selectedAccounts[platform]!.isEmpty) {
          _selectedAccounts.remove(platform);
        }
      } else {
        print('Adding account: $accountId to platform: $platform');
        _selectedAccounts[platform]!.add(accountId);
      }
    });
  }

  Future<void> _pickMedia() async {
    // Show a dialog to select media type
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Seleziona tipo di media'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: Icon(Icons.photo),
                title: Text('Immagine'),
                onTap: () async {
                  Navigator.pop(context);
                  final XFile? image = await _picker.pickImage(source: ImageSource.gallery);
                  if (image != null) {
                    setState(() {
                      _videoFile = File(image.path);
                      _showCheckmark = true;
                      _isImageFile = true;
                    });
                  }
                },
              ),
              ListTile(
                leading: Icon(Icons.videocam),
                title: Text('Video'),
                onTap: () async {
                  Navigator.pop(context);
                  final XFile? video = await _picker.pickVideo(source: ImageSource.gallery);
                  if (video != null) {
                    final videoFile = File(video.path);
                    setState(() {
                      _videoFile = videoFile;
                      _showCheckmark = true;
                      _isImageFile = false;
                    });
                    
                    // Inizializza il player del video
                    _initializeVideoPlayer(videoFile);
                  }
                },
              ),
            ],
          ),
        );
      },
    );
  }

  Future<void> _validateAndProceed(bool isScheduling) async {
    if (_videoFile == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Seleziona un media prima di procedere')),
      );
      return;
    }

    if (_selectedAccounts.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Seleziona almeno un account prima di procedere')),
      );
      return;
    }

    if (isScheduling) {
      final theme = Theme.of(context);
      final now = DateTime.now();
      
      // Show date picker with custom theme
      final DateTime? picked = await showDatePicker(
        context: context,
        initialDate: _scheduledDateTime ?? now,
        firstDate: now,
        lastDate: now.add(const Duration(days: 365)),
        builder: (context, child) {
          return Theme(
            data: Theme.of(context).copyWith(
              colorScheme: ColorScheme.light(
                primary: theme.colorScheme.primary,
                onPrimary: Colors.white,
                surface: theme.colorScheme.surface,
                onSurface: theme.colorScheme.onSurface,
              ),
              textButtonTheme: TextButtonThemeData(
                style: TextButton.styleFrom(
                  foregroundColor: theme.colorScheme.primary,
                ),
              ),
            ),
            child: child!,
          );
        },
      );

      if (picked != null) {
        // Show time picker with custom theme
        final TimeOfDay? time = await showTimePicker(
          context: context,
          initialTime: TimeOfDay.fromDateTime(_scheduledDateTime ?? now),
          builder: (context, child) {
            return Theme(
              data: Theme.of(context).copyWith(
                timePickerTheme: TimePickerThemeData(
                  dialHandColor: theme.colorScheme.primary.withOpacity(0.15),
                  hourMinuteTextColor: theme.colorScheme.onSurface,
                  dayPeriodTextColor: theme.colorScheme.onSurface,
                  dialTextColor: theme.colorScheme.onSurface,
                  dialBackgroundColor: theme.colorScheme.surfaceVariant,
                  entryModeIconColor: theme.colorScheme.primary,
                  hourMinuteShape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  helpTextStyle: TextStyle(
                    color: theme.colorScheme.onSurface,
                  ),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(24),
                  ),
                ),
                colorScheme: ColorScheme.light(
                  primary: theme.colorScheme.primary.withOpacity(0.7),
                  onPrimary: Colors.white,
                  surface: theme.colorScheme.surface,
                  onSurface: theme.colorScheme.onSurface,
                ),
                textButtonTheme: TextButtonThemeData(
                  style: TextButton.styleFrom(
                    foregroundColor: theme.colorScheme.primary,
                  ),
                ),
              ),
              child: child!,
            );
          },
        );

        if (time != null) {
          final scheduledDateTime = DateTime(
            picked.year,
            picked.month,
            picked.day,
            time.hour,
            time.minute,
          );
          
          // Navigate to the new SchedulePostPage
          final result = await Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => SchedulePostPage(
                videoFile: _videoFile!,
                title: _titleController.text,
                description: _descriptionController.text,
                selectedAccounts: _selectedAccounts,
                socialAccounts: _socialAccounts,
                scheduledDateTime: scheduledDateTime,
                onConfirm: () {
                  setState(() {
                    _scheduledDateTime = scheduledDateTime;
                    _isScheduled = true;
                  });
                },
              ),
            ),
          );

          if (result == true) {
            setState(() {
              _scheduledDateTime = scheduledDateTime;
              _isScheduled = true;
            });
            _refreshPage();
          }
        }
      }
    } else {
      // Show confirmation page for immediate upload
      final result = await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => UploadConfirmationPage(
            videoFile: _videoFile!,
            title: _titleController.text,
            description: _descriptionController.text,
            selectedAccounts: _selectedAccounts,
            socialAccounts: _socialAccounts,
            onConfirm: () {},
            isDraft: false,
            isImageFile: _isImageFile,
            instagramContentType: _instagramContentType,
          ),
        ),
      );

      if (result == true) {
        _uploadVideo();
      }
    }
  }

  Future<void> _uploadVideo() async {
    try {
      if (_videoFile == null) {
        throw Exception('No video file selected');
      }
      if (_selectedAccounts.isEmpty) {
        throw Exception('No social media accounts selected');
      }

      // Check if user has enough credits
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser != null) {
        final creditsSnapshot = await FirebaseDatabase.instance.ref()
            .child('users')
            .child('users') // Match the path style with the rest of the database
            .child(currentUser.uid)
            .child('credits')
            .get();

        int userCredits = creditsSnapshot.exists ? (creditsSnapshot.value as int?) ?? 0 : 0;
        
        if (userCredits < 250) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Not enough credits. You need 250 credits to upload a video.'),
                backgroundColor: Colors.red,
                duration: Duration(seconds: 4),
              ),
            );
          }
          return;
        }
      }

      // Initialize the upload status
      setState(() {
        _isUploading = true;
        _uploadStatuses.clear();
      });

      // Prima di tutto, carica il file su Cloudflare R2
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Uploading media to cloud storage...'),
          duration: Duration(seconds: 2),
        ),
      );
      
      // Aggiungi un UploadStatus per Cloudflare
      _uploadStatuses['Cloudflare_storage'] = UploadStatus(
        platform: 'Cloudflare',
        accountId: 'R2Storage',
        state: UploadState.uploading,
        progress: 0.0,
      );

      // Carica il file su Cloudflare R2
      String? cloudflareUrl;
      try {
        cloudflareUrl = await _uploadToCloudflare(_videoFile!, isImage: _isImageFile);
        
        if (cloudflareUrl == null) {
          throw Exception('Failed to upload media to Cloudflare');
        }
        
        // Aggiorna lo stato di upload
        _uploadStatuses['Cloudflare_storage'] = UploadStatus(
          platform: 'Cloudflare',
          accountId: 'R2Storage',
          state: UploadState.completed,
          progress: 1.0,
        );
        
        print('Successfully uploaded media to Cloudflare: $cloudflareUrl');
        
        // Mostra una notifica di successo
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Media uploaded to cloud storage successfully!'),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 2),
            ),
          );
        }
      } catch (e) {
        // Aggiorna lo stato di upload
        _uploadStatuses['Cloudflare_storage'] = UploadStatus(
          platform: 'Cloudflare',
          accountId: 'R2Storage',
          state: UploadState.error,
          error: e.toString(),
        );
        
        throw Exception('Failed to upload media to Cloudflare: $e');
      }

      // Prepare upload status trackers
      for (var platform in _selectedAccounts.keys) {
        for (var accountId in _selectedAccounts[platform]!) {
          final key = '${platform}_$accountId';
          _uploadStatuses[key] = UploadStatus(
            platform: platform,
            accountId: accountId,
          );
        }
      }

      List<Future> uploadTasks = [];
      List<String> uploadedPlatforms = [];

      // Prepara gli upload per ogni piattaforma selezionata
      for (var platform in _selectedAccounts.keys) {
        for (var accountId in _selectedAccounts[platform]!) {
          switch (platform) {
            case 'Twitter':
              uploadTasks.add(_uploadToTwitter(accountId, cloudflareUrl).then((_) {
                uploadedPlatforms.add(platform);
              }).catchError((e) {
                print('Error uploading to Twitter: $e');
                throw e;
              }));
              break;
            case 'YouTube':
              uploadTasks.add(_uploadToYouTube(accountId, cloudflareUrl).then((_) {
                uploadedPlatforms.add(platform);
              }));
              break;
            case 'TikTok':
              uploadTasks.add(_uploadToTikTok(accountId, cloudflareUrl).then((_) {
                uploadedPlatforms.add(platform);
              }));
              break;
            case 'Instagram':
              uploadTasks.add(_uploadToInstagram(accountId, cloudflareUrl).then((_) {
                uploadedPlatforms.add(platform);
              }));
              break;
            case 'Facebook':
              uploadTasks.add(_uploadToFacebook(accountId, cloudflareUrl).then((_) {
                uploadedPlatforms.add(platform);
              }));
              break;
            case 'Threads':
              uploadTasks.add(_uploadToThreads(accountId, cloudflareUrl).then((_) {
                uploadedPlatforms.add(platform);
              }));
              break;
          }
        }
      }

      // Esegui tutti gli upload in parallelo
      await Future.wait(uploadTasks);

      // Salva la cronologia del post
      if (currentUser != null && uploadedPlatforms.isNotEmpty) {
        // Deduct 250 credits after successful upload
        final creditsRef = _database
            .child('users')
            .child('users')
            .child(currentUser.uid)
            .child('credits');
        
        // Get current credits
        final creditsSnapshot = await creditsRef.get();
        int currentCredits = creditsSnapshot.exists ? (creditsSnapshot.value as int?) ?? 0 : 0;
        
        // Update credits (deduct 250)
        await creditsRef.set(currentCredits - 250);
        
        await _database
            .child('users')
            .child('users')
            .child(currentUser.uid)
            .child('posts')
            .push()
            .set({
          'title': _titleController.text,
          'description': _descriptionController.text,
          'video_path': _videoFile?.path,
          'cloudflare_url': cloudflareUrl, // Aggiungi URL Cloudflare
          'created_at': DateTime.now().millisecondsSinceEpoch,
          'platforms': uploadedPlatforms,
          'is_scheduled': false,
          'scheduled_time': null,
          'status': 'published',
        });
      }

      if (mounted) {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => UploadConfirmationPage(
              videoFile: _videoFile!,
              title: _titleController.text,
              description: _descriptionController.text,
              selectedAccounts: _selectedAccounts,
              socialAccounts: _socialAccounts,
              onConfirm: () {},
              isDraft: false,
              isImageFile: _isImageFile,
              instagramContentType: _instagramContentType,
              cloudflareUrl: cloudflareUrl, // Passa l'URL di Cloudflare
            ),
          ),
        );

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              uploadedPlatforms.isEmpty
                ? 'No videos were uploaded, please check errors and try again'
                : 'Video uploaded successfully to all platforms!'
            ),
            backgroundColor: uploadedPlatforms.isEmpty ? Colors.red : Theme.of(context).colorScheme.primary,
          ),
        );
      }
    } catch (e) {
      print('Error in _uploadVideo: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error during upload: $e')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isUploading = false;
        });
      }
    }
  }

  // Metodo per aggiornare lo stato di upload
  void _updateUploadStatus(String platform, String accountId, {
    UploadState? state,
    String? error,
    double? progress,
  }) {
    final key = '${platform}_$accountId';
    if (mounted) {
      setState(() {
        final status = _uploadStatuses[key];
        if (status != null) {
          if (state != null) status.state = state;
          if (error != null) status.error = error;
          if (progress != null) status.progress = progress;
        }
      });
    }
  }

  // Helper method to sanitize database paths
  String _sanitizePath(String path) {
    return path.replaceAll(RegExp(r'[@.#$\[\]]'), '_');
  }

  Future<void> _loadSocialAccounts() async {
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) {
        throw Exception('User not authenticated');
      }

      // Load Twitter accounts
      final twitterSnapshot = await _database
          .child('users')
          .child('users')
          .child(currentUser.uid)
          .child('social_accounts')
          .child('twitter')
          .get();
      
      if (twitterSnapshot.exists && mounted) {
        final twitterData = twitterSnapshot.value as Map<dynamic, dynamic>;
        final twitterAccounts = twitterData.entries.map((entry) {
          final accountData = entry.value as Map<dynamic, dynamic>;
          return {
            'id': entry.key,
            'username': accountData['username'] ?? '',
            'display_name': accountData['display_name'] ?? accountData['username'] ?? '',
            'profile_image_url': accountData['profile_image_url'] ?? '',
            'followers_count': accountData['followers_count']?.toString() ?? '0',
            'access_token': accountData['access_token'] ?? '',
            'access_token_secret': accountData['access_token_secret'] ?? '',
            'bearer_token': accountData['bearer_token'] ?? '',
          };
        }).where((account) => account['username'].toString().isNotEmpty).toList();

        if (mounted) {
          setState(() {
            _socialAccounts['Twitter'] = twitterAccounts;
          });
        }
      }

      // Load YouTube accounts
      final youtubeSnapshot = await _database
          .child('users')
          .child(currentUser.uid)
          .child('youtube')
          .get();
      
      if (youtubeSnapshot.exists && mounted) {
        final youtubeData = youtubeSnapshot.value as Map<dynamic, dynamic>;
        final youtubeAccounts = youtubeData.entries.map((entry) {
          final accountData = entry.value as Map<dynamic, dynamic>;
          if (accountData['status'] != 'active') return null;
          return {
            'id': entry.key,
            'username': accountData['channel_name'] ?? '',
            'display_name': accountData['channel_name'] ?? '',
            'profile_image_url': accountData['thumbnail_url'] ?? '',
            'followers_count': accountData['subscriber_count']?.toString() ?? '0',
            'channel_id': accountData['channel_id'] ?? '',
            'video_count': accountData['video_count']?.toString() ?? '0',
            'access_token': accountData['access_token'] ?? '',
          };
        }).where((account) => account != null).cast<Map<String, dynamic>>().toList();

        if (mounted) {
          setState(() {
            _socialAccounts['YouTube'] = youtubeAccounts;
          });
        }
      }
      
      // Load Facebook accounts
      final facebookSnapshot = await _database
          .child('users')
          .child(currentUser.uid)
          .child('facebook')
          .get();
      
      if (facebookSnapshot.exists && mounted) {
        final facebookData = facebookSnapshot.value as Map<dynamic, dynamic>;
        final facebookAccounts = facebookData.entries.map((entry) {
          final accountData = entry.value as Map<dynamic, dynamic>;
          if (accountData['status'] != 'active') return null;
          return {
            'id': entry.key,
            'username': accountData['name'] ?? '',
            'display_name': accountData['display_name'] ?? accountData['name'] ?? '',
            'profile_image_url': accountData['profile_image_url'] ?? '',
            'followers_count': accountData['followers_count']?.toString() ?? '0',
            'page_id': accountData['page_id'] ?? '',
            'page_type': accountData['page_type'] ?? '',
            'access_token': accountData['access_token'] ?? '',
          };
        }).where((account) => account != null).cast<Map<String, dynamic>>().toList();

        if (mounted) {
          setState(() {
            _socialAccounts['Facebook'] = facebookAccounts;
          });
        }
      }

      // Load Instagram accounts
      final instagramSnapshot = await _database
          .child('users')
          .child(currentUser.uid)
          .child('instagram')
          .get();
      
      if (instagramSnapshot.exists && mounted) {
        final instagramData = instagramSnapshot.value as Map<dynamic, dynamic>;
        final instagramAccounts = instagramData.entries.map((entry) {
          final accountData = entry.value as Map<dynamic, dynamic>;
          if (accountData['status'] != 'active') return null;
          return {
            'id': entry.key,
            'username': accountData['username'] ?? '',
            'display_name': accountData['display_name'] ?? accountData['username'] ?? '',
            'profile_image_url': accountData['profile_image_url'] ?? '',
            'followers_count': accountData['followers_count']?.toString() ?? '0',
            'user_id': accountData['user_id'] ?? '',
            'access_token': accountData['access_token'] ?? '',
          };
        }).where((account) => account != null).cast<Map<String, dynamic>>().toList();

        if (mounted) {
          setState(() {
            _socialAccounts['Instagram'] = instagramAccounts;
          });
        }
      }
      
      // Load Threads accounts
      final threadsSnapshot = await _database
          .child('users')
          .child('users')
          .child(currentUser.uid)
          .child('social_accounts')
          .child('threads')
          .get();
      
      if (threadsSnapshot.exists && mounted) {
        print('Found Threads accounts for user ${currentUser.uid}');
        final threadsData = threadsSnapshot.value as Map<dynamic, dynamic>;
        final threadsAccounts = threadsData.entries.map((entry) {
          final accountData = entry.value as Map<dynamic, dynamic>;
          if (accountData['status'] != 'active') return null;
          return {
            'id': entry.key,
            'username': accountData['username'] ?? '',
            'display_name': accountData['display_name'] ?? accountData['username'] ?? '',
            'profile_image_url': accountData['profile_image_url'] ?? '',
            'followers_count': '0', // Threads API non fornisce il numero di followers
            'user_id': accountData['user_id'] ?? entry.key,
            'access_token': accountData['access_token'] ?? '',
          };
        }).where((account) => account != null).cast<Map<String, dynamic>>().toList();

        print('Loaded ${threadsAccounts.length} Threads accounts');
        if (mounted) {
          setState(() {
            _socialAccounts['Threads'] = threadsAccounts;
          });
        }
      } else {
        print('No Threads accounts found for user ${currentUser.uid}');
        if (mounted) {
          setState(() {
            _socialAccounts['Threads'] = [];
          });
        }
      }
    } catch (e) {
      print('Error loading social accounts: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading social accounts: $e')),
        );
      }
    }
  }

  Future<void> _uploadToTwitter(String accountId, String? cloudflareUrl) async {
    try {
      _updateUploadStatus('Twitter', accountId, state: UploadState.uploading);

      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception('User not authenticated');

      print('Uploading to Twitter with account ID: $accountId');

      // Get account data from Firebase
      final accountSnapshot = await _database
          .child('users')
          .child('users')
          .child(currentUser.uid)
          .child('social_accounts')
          .child('twitter')
          .child(accountId)
          .get();

      if (!accountSnapshot.exists) {
        throw Exception('Twitter account not found');
      }

      final accountData = accountSnapshot.value as Map<dynamic, dynamic>;
      
      print('Account data retrieved: ${accountData['access_token']} - ${accountData['access_token_secret']}');

      // Initialize Twitter API with empty bearer token to force OAuth 1.0a for all operations
      final twitter = v2.TwitterApi(
        bearerToken: '',  // Empty bearer token to force OAuth 1.0a
        oauthTokens: v2.OAuthTokens(
          consumerKey: 'sTn3lkEWn47KiQl41zfGhjYb4',
          consumerSecret: 'Z5UvLwLysPoX2fzlbebCIn63cQ3yBo0uXiqxK88v1fXcz3YrYA',
          accessToken: accountData['access_token'] ?? '',
          accessTokenSecret: accountData['access_token_secret'] ?? '',
        ),
        retryConfig: v2.RetryConfig(
          maxAttempts: 5,
          onExecute: (event) => print(
            'Retry after ${event.intervalInSeconds} seconds... '
            '[${event.retryCount} times]'
          ),
        ),
        timeout: const Duration(seconds: 30),
      );

      print('Starting media upload...');
      
      // Upload the video using the media upload endpoint (v1.1)
      final uploadResponse = await twitter.media.uploadMedia(
        file: _videoFile!,
        onProgress: (event) {
          switch (event.state) {
            case v2.UploadState.preparing:
              print('Upload is preparing...');
              _updateUploadStatus('Twitter', accountId, progress: 0.1);
              break;
            case v2.UploadState.inProgress:
              print('${event.progress}% completed...');
              _updateUploadStatus('Twitter', accountId, progress: event.progress / 100);
              break;
            case v2.UploadState.completed:
              print('Upload has completed!');
              _updateUploadStatus('Twitter', accountId, progress: 1.0);
              break;
          }
        },
        onFailed: (error) {
          print('Upload failed: ${error.message}');
          _updateUploadStatus(
            'Twitter',
            accountId,
            state: UploadState.error,
            error: error.message,
          );
          throw Exception(error.message);
        },
      );

      if (uploadResponse.data == null) {
        throw Exception('Failed to upload media to Twitter');
      }

      print('Video uploaded successfully, creating tweet...');

      // Create tweet with the uploaded video using OAuth 1.0a
      final tweet = await twitter.tweets.createTweet(
        text: _descriptionController.text,
        media: v2.TweetMediaParam(
          mediaIds: [uploadResponse.data!.id],
        ),
      );

      // Save tweet ID in the account data
      if (tweet.data != null) {
        final accountIndex = _socialAccounts['Twitter']?.indexWhere(
          (account) => account['id'] == accountId
        );
        
        if (accountIndex != null && accountIndex >= 0) {
          if (mounted) {
            setState(() {
              _socialAccounts['Twitter']![accountIndex]['tweet_id'] = tweet.data.id;
            });
          }
        }
      }

      _updateUploadStatus('Twitter', accountId, state: UploadState.completed);
      print('Tweet posted successfully with video!');
    } catch (e) {
      print('Error during Twitter upload: $e');
      _updateUploadStatus(
        'Twitter',
        accountId,
        state: UploadState.error,
        error: e.toString(),
      );
      rethrow;
    }
  }

  Future<void> _uploadToYouTube(String accountId, String? cloudflareUrl) async {
    try {
      _updateUploadStatus('YouTube', accountId, state: UploadState.uploading);

      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception('User not authenticated');

      print('Uploading to YouTube with account ID: $accountId');

      // Get account data from Firebase
      final accountSnapshot = await _database
          .child('users')
          .child(currentUser.uid)
          .child('youtube')
          .child(accountId)
          .get();

      if (!accountSnapshot.exists) {
        throw Exception('YouTube account not found');
      }

      final accountData = accountSnapshot.value as Map<dynamic, dynamic>;
      
      // Initialize Google Sign-In
      final GoogleSignIn _googleSignIn = GoogleSignIn(
        scopes: [
          'https://www.googleapis.com/auth/youtube.upload',
          'https://www.googleapis.com/auth/youtube.readonly',
          'https://www.googleapis.com/auth/youtube'
        ],
        clientId: '1095391771291-cqpq4ci6m4ahvqeea21u9c9g4r4ekr02.apps.googleusercontent.com',
        signInOption: SignInOption.standard,
      );

      // Sign in with Google
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      if (googleUser == null) {
        throw Exception('Google sign in cancelled');
      }

      // Get authentication details
      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
      if (googleAuth.accessToken == null) {
        throw Exception('Failed to get access token');
      }

      // Prepare video metadata
      final videoTitle = _titleController.text.isNotEmpty ? _titleController.text : _videoFile!.path.split('/').last;
      final videoMetadata = {
        'snippet': {
          'title': videoTitle,
          'description': _descriptionController.text,
          'categoryId': '22', // People & Blogs category
        },
        'status': {
          'privacyStatus': 'public',
          'madeForKids': false,
        }
      };

      // First, upload the video
      final uploadResponse = await http.post(
        Uri.parse('https://www.googleapis.com/upload/youtube/v3/videos?part=snippet,status'),
        headers: {
          'Authorization': 'Bearer ${googleAuth.accessToken}',
          'Content-Type': 'application/octet-stream',
          'X-Upload-Content-Type': 'video/*',
          'X-Upload-Content-Length': _videoFile!.lengthSync().toString(),
        },
        body: await _videoFile!.readAsBytes(),
      );

      if (uploadResponse.statusCode != 200) {
        throw Exception('Failed to upload video: ${uploadResponse.body}');
      }

      final videoData = json.decode(uploadResponse.body);
      final videoId = videoData['id'];

      // Then, update the video metadata
      final metadataResponse = await http.put(
        Uri.parse('https://www.googleapis.com/youtube/v3/videos?part=snippet,status'),
        headers: {
          'Authorization': 'Bearer ${googleAuth.accessToken}',
          'Content-Type': 'application/json',
        },
        body: json.encode({
          'id': videoId,
          ...videoMetadata,
        }),
      );

      if (metadataResponse.statusCode != 200) {
        throw Exception('Failed to update video metadata: ${metadataResponse.body}');
      }

      // Update account data with the new video
      await _database
          .child('users')
          .child(currentUser.uid)
          .child('youtube')
          .child(accountId)
          .update({
        'video_count': (accountData['video_count'] ?? 0) + 1,
        'last_sync': DateTime.now().millisecondsSinceEpoch,
      });

      // Save video information to Firebase
      final videoRef = _database
          .child('users')
          .child('users')
          .child(currentUser.uid)
          .child('videos')
          .push();

      await videoRef.set({
        'account_id': accountId,
        'account_username': accountData['channel_name'],
        'description': _descriptionController.text,
        'media_id': videoId,
        'platforms': ['YouTube'],
        'status': 'published',
        'timestamp': DateTime.now().millisecondsSinceEpoch,
        'title': videoTitle,
        'video_path': _videoFile!.path,
        'user_id': currentUser.uid,
      });

      _updateUploadStatus('YouTube', accountId, state: UploadState.completed);
      print('Video uploaded successfully to YouTube!');
    } catch (e) {
      print('Error during YouTube upload: $e');
      _updateUploadStatus(
        'YouTube',
        accountId,
        state: UploadState.error,
        error: e.toString(),
      );
      rethrow;
    }
  }

  Future<void> _uploadToTikTok(String accountId, String? cloudflareUrl) async {
    try {
      _updateUploadStatus('TikTok', accountId, state: UploadState.uploading);
      // Implementa la logica di upload per TikTok
      await Future.delayed(const Duration(seconds: 2)); // Simulazione
      _updateUploadStatus('TikTok', accountId, state: UploadState.completed);
    } catch (e) {
      _updateUploadStatus('TikTok', accountId,
        state: UploadState.error,
        error: e.toString(),
      );
      rethrow;
    }
  }

  Future<void> _uploadToInstagram(String accountId, String? cloudflareUrl) async {
    try {
      _updateUploadStatus('Instagram', accountId, state: UploadState.uploading);
      // Implementa la logica di upload per Instagram
      await Future.delayed(const Duration(seconds: 2)); // Simulazione
      _updateUploadStatus('Instagram', accountId, state: UploadState.completed);
    } catch (e) {
      _updateUploadStatus('Instagram', accountId,
        state: UploadState.error,
        error: e.toString(),
      );
      rethrow;
    }
  }

  Future<String?> _uploadToFacebook(String accountId, String? cloudflareUrl) async {
    try {
      if (mounted) {
        setState(() {
          _uploadStatuses['Facebook_$accountId'] = UploadStatus(
            platform: 'Facebook',
            accountId: accountId,
            state: UploadState.uploading
          );
        });
      }

      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception('User not authenticated');

      // Get account data from Firebase
      final accountSnapshot = await _database
          .child('users')
          .child(currentUser.uid)
          .child('facebook')
          .child(accountId)
          .get();

      if (!accountSnapshot.exists) {
        throw Exception('Facebook account not found');
      }

      final accountData = accountSnapshot.value as Map<dynamic, dynamic>;
      final accessToken = accountData['access_token'];
      final pageId = accountData['page_id'];
      
      if (accessToken == null || accessToken.isEmpty) {
        throw Exception('Facebook access token not found');
      }
      
      if (pageId == null || pageId.isEmpty) {
        throw Exception('Facebook page ID not found');
      }

      // Prepare the video file
      final videoFile = _videoFile!;
      final fileSize = await videoFile.length();
      
      // Log network conditions to help with debugging
      print('Starting Facebook upload for file size: $fileSize bytes');
      
      // STEP 1: Start upload session
      final startSessionResponse = await http.post(
        Uri.parse('https://graph.facebook.com/v18.0/$pageId/videos'),
        body: {
          'access_token': accessToken,
          'upload_phase': 'start',
          'file_size': fileSize.toString(),
        },
      ).timeout(const Duration(seconds: 60), onTimeout: () {
        throw TimeoutException('Start session request timed out');
      });
      
      if (startSessionResponse.statusCode != 200) {
        throw Exception('Failed to create Facebook upload session: ${startSessionResponse.body}');
      }
      
      final sessionData = json.decode(startSessionResponse.body);
      final uploadSessionId = sessionData['upload_session_id'];
      
      // STEP 2: Upload the video data in chunks
      int offset = 0;
      final chunkSize = 250 * 1024; // Further reduced to 250KB as per VEDI.md
      
      final videoBytes = await videoFile.readAsBytes();
      
      while (offset < fileSize) {
        final end = offset + chunkSize < fileSize ? offset + chunkSize : fileSize;
        final chunk = videoBytes.sublist(offset, end);
        
        bool chunkUploaded = false;
        int retryCount = 0;
        const maxRetries = 5; // Increased from 3 to 5
        
        // Retry loop for this chunk
        while (!chunkUploaded && retryCount < maxRetries) {
          try {
            // Create URL with query parameters
            final uri = Uri.parse('https://graph.facebook.com/v18.0/$pageId/videos')
                .replace(queryParameters: {
              'access_token': accessToken,
              'upload_phase': 'transfer',
              'upload_session_id': uploadSessionId,
              'start_offset': offset.toString(),
            });
            
            // Send the chunk as raw binary data
            final transferRequest = http.Request('POST', uri);
            transferRequest.bodyBytes = chunk;
            
            final client = http.Client();
            // Implement longer timeout for request (60 seconds)
            final transferResponse = await client.send(transferRequest)
                .timeout(const Duration(seconds: 60), onTimeout: () {
              throw TimeoutException('Upload chunk request timed out');
            });
            
            final transferResponseBody = await http.Response.fromStream(transferResponse);
            
            if (transferResponseBody.statusCode != 200) {
              throw Exception('Failed to upload video chunk to Facebook: ${transferResponseBody.body}');
            }
            
            // Chunk was successful
            chunkUploaded = true;
            client.close();
            
            // Update progress indicator (0.0 to 1.0)
            final progress = (offset + chunk.length) / fileSize;
            if (mounted) {
              setState(() {
                _uploadStatuses['Facebook_$accountId'] = UploadStatus(
                  platform: 'Facebook',
                  accountId: accountId,
                  state: UploadState.uploading,
                  progress: progress
                );
              });
            }
            
            // Report progress more explicitly
            print('Successfully uploaded chunk: $offset to ${offset + chunk.length} of $fileSize');
          } catch (e) {
            retryCount++;
            print('Error uploading chunk at offset $offset (attempt $retryCount): $e');
            
            if (retryCount >= maxRetries) {
              throw Exception('Failed to upload video chunk after $maxRetries attempts: $e');
            }
            
            // Wait longer before retry with exponential backoff (minimum 5 seconds)
            final backoffSeconds = 5 * (retryCount + 1); // 10, 15, 20, 25 seconds
            print('Retrying in $backoffSeconds seconds...');
            await Future.delayed(Duration(seconds: backoffSeconds));
          }
        }
        
        offset = end;
      }
      
      // STEP 3: Finalize the upload
      bool finalizationSuccess = false;
      int finalizeRetryCount = 0;
      const maxFinalizeRetries = 3;
      
      while (!finalizationSuccess && finalizeRetryCount < maxFinalizeRetries) {
        try {
          print('Attempting to finalize Facebook upload...');
          final finishResponse = await http.post(
            Uri.parse('https://graph.facebook.com/v18.0/$pageId/videos'),
            body: {
              'access_token': accessToken,
              'upload_phase': 'finish',
              'upload_session_id': uploadSessionId,
              'title': _titleController.text.isNotEmpty ? _titleController.text : 'Video from Viralyst',
              'description': _descriptionController.text,
            },
          ).timeout(const Duration(seconds: 60), onTimeout: () {
            throw TimeoutException('Finalize request timed out');
          });
          
          if (finishResponse.statusCode != 200) {
            throw Exception('Failed to finalize Facebook video upload: ${finishResponse.body}');
          }
          
          final finishData = json.decode(finishResponse.body);
          final videoId = finishData['id'];
          finalizationSuccess = true;
          print('Successfully uploaded video to Facebook with ID: $videoId');
          
          if (mounted) {
            setState(() {
              _uploadStatuses['Facebook_$accountId'] = UploadStatus(
                platform: 'Facebook',
                accountId: accountId,
                state: UploadState.completed,
                progress: 1.0
              );
            });
          }

          return videoId;
        } catch (e) {
          finalizeRetryCount++;
          print('Error finalizing upload (attempt $finalizeRetryCount): $e');
          
          if (finalizeRetryCount >= maxFinalizeRetries) {
            throw Exception('Failed to finalize video upload after $maxFinalizeRetries attempts: $e');
          }
          
          // Longer wait before retry with exponential backoff
          final backoffSeconds = 8 * finalizeRetryCount;
          print('Retrying finalization in $backoffSeconds seconds...');
          await Future.delayed(Duration(seconds: backoffSeconds));
        }
      }
      
      throw Exception('Failed to complete Facebook upload process');
    } catch (e) {
      if (mounted) {
        setState(() {
          _uploadStatuses['Facebook_$accountId'] = UploadStatus(
            platform: 'Facebook',
            accountId: accountId,
            state: UploadState.error,
            error: e.toString(),
            progress: 0.0
          );
        });
      }
      rethrow;
    }
  }

  Future<void> _uploadToThreads(String accountId, String? cloudflareUrl) async {
    try {
      _updateUploadStatus('Threads', accountId, state: UploadState.uploading);
      
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception('User not authenticated');

      print('Uploading to Threads with account ID: $accountId');

      // Get account data from Firebase
      final accountSnapshot = await _database
          .child('users')
          .child('users')
          .child(currentUser.uid)
          .child('social_accounts')
          .child('threads')
          .child(accountId)
          .get();

      if (!accountSnapshot.exists) {
        throw Exception('Threads account not found');
      }

      final accountData = accountSnapshot.value as Map<dynamic, dynamic>;
      final accessToken = accountData['access_token'];
      final userId = accountData['user_id'] ?? accountId;
      
      if (accessToken == null || accessToken.isEmpty) {
        throw Exception('Threads access token not found');
      }
      
      // Nota: L'API di Threads attualmente non supporta la pubblicazione diretta di contenuti tramite API
      // Questo è un placeholder per futura implementazione quando l'API sarà disponibile
      // Per ora mostreremo un messaggio all'utente spiegando la limitazione

      await Future.delayed(const Duration(seconds: 2)); // Simula un ritardo di rete
      
      // Update upload status to show a message to the user
      _updateUploadStatus(
        'Threads', 
        accountId,
        state: UploadState.error,
        error: 'Threads API currently does not support direct posting. The video will need to be posted manually.',
      );
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Threads API limitations: direct posting not available. Please post manually.'),
            duration: Duration(seconds: 5),
          ),
        );
      }
      
      // Update the last sync time for the account
      await _database
          .child('users')
          .child('users')
          .child(currentUser.uid)
          .child('social_accounts')
          .child('threads')
          .child(accountId)
          .update({
        'last_sync': DateTime.now().millisecondsSinceEpoch,
      });
      
      print('Threads upload process completed (with API limitation notice)');
      
    } catch (e) {
      print('Error during Threads upload process: $e');
      _updateUploadStatus(
        'Threads', 
        accountId,
        state: UploadState.error,
        error: e.toString(),
      );
      rethrow;
    }
  }

  Future<String> _copyVideoToLocalStorage(File videoFile) async {
    final directory = await getApplicationDocumentsDirectory();
    final fileName = videoFile.path.split('/').last;
    final localPath = '${directory.path}/$fileName';
    
    // Copy the file to local storage if it doesn't exist
    if (!await File(localPath).exists()) {
      await videoFile.copy(localPath);
    }
    
    return localPath;
  }

  Future<void> _saveAsDraft() async {
    if (_videoFile == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a video first')),
      );
      return;
    }

    if (_selectedAccounts.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select at least one account')),
      );
      return;
    }

    setState(() {
      _isUploading = true;
    });

    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser != null) {
        // Copy video to local storage
        final localVideoPath = await _copyVideoToLocalStorage(_videoFile!);
        
        final videoRef = _database
            .child('users')
            .child('users')
            .child(currentUser.uid)
            .child('videos')
            .push();

        // Prepare accounts data following the same structure as schedule_confirmation.dart
        final accountsData = <String, List<Map<String, dynamic>>>{};
        for (var platform in _selectedAccounts.keys) {
          final accounts = _selectedAccounts[platform]!;
          final platformAccounts = <Map<String, dynamic>>[];
          
          for (var accountId in accounts) {
            final account = _socialAccounts[platform]?.firstWhere(
              (acc) => acc['id'] == accountId,
              orElse: () => <String, dynamic>{},
            );
            
            if (account != null && account.isNotEmpty) {
              platformAccounts.add({
                'username': account['username'] ?? '',
                'display_name': account['display_name'] ?? account['username'] ?? '',
                'profile_image_url': account['profile_image_url'] ?? '',
                'followers_count': account['followers_count']?.toString() ?? '0',
              });
            }
          }
          
          if (platformAccounts.isNotEmpty) {
            accountsData[platform.toLowerCase()] = platformAccounts;
          }
        }

        final videoData = {
          'id': videoRef.key,
          'title': _titleController.text,
          'description': _descriptionController.text,
          'platforms': _selectedAccounts.keys.toList(),
          'status': 'draft', // Always save as draft when using _saveAsDraft
          'timestamp': DateTime.now().millisecondsSinceEpoch,
          'video_path': localVideoPath,
          'thumbnail_path': _thumbnailPath ?? '',
          'accounts': accountsData,
          'user_id': currentUser.uid,
          'scheduled_time': null, // No scheduled time for drafts
        };

        await videoRef.set(videoData);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 8),
                Text('Video saved as draft successfully'),
              ],
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10.0),
            ),
            duration: Duration(seconds: 3),
          ),
        );
        _refreshPage();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving draft: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isUploading = false;
        });
      }
    }
  }

  // Metodo per generare descrizione generale
  Future<void> _generateDescription() async {
    if (_promptController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Inserisci un prompt per la descrizione')),
      );
      return;
    }

    setState(() {
      _isGeneratingDescription = true;
    });

    try {
      final response = await http.post(
        Uri.parse('https://api.openai.com/v1/chat/completions'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $_apiKey',
        },
        body: jsonEncode({
          'model': 'gpt-4o-mini',
          'messages': [
            {
              'role': 'user',
              'content': 'Scrivi una descrizione per social media. La risposta deve essere ben formattata e non superare 180 caratteri spazi inclusi. Usa emoji in formato leggibile, non usare parole come "scopri", "esplora", "unisciti a noi". Ecco gli argomenti del video: ${_promptController.text}',
            }
          ],
          'max_tokens': _maxTokens,
          'temperature': 0.7,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        String generatedText = data['choices'][0]['message']['content'];
        
        // Clean up any potential encoding issues
        generatedText = generatedText
            .replaceAll(RegExp(r'\\u[0-9a-fA-F]{4}'), '') // Remove broken unicode
            .replaceAll(RegExp(r'[^\x00-\x7F]+'), '') // Remove non-ASCII chars
            .replaceAll(RegExp(r'\s+'), ' ') // Normalize whitespace
            .trim();
        
        setState(() {
          _descriptionController.text = generatedText;
        });
      } else {
        throw Exception('Failed to generate description');
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error generating description: ${e.toString()}')),
      );
    } finally {
      setState(() {
        _isGeneratingDescription = false;
      });
    }
  }

  // Metodo per generare descrizione per una piattaforma specifica
  Future<void> _generatePlatformDescription(String platform) async {
    if (_platformPromptControllers[platform]?.text.isEmpty ?? true) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Inserisci un prompt per la descrizione')),
      );
      return;
    }

    setState(() {
      _isGeneratingDescription = true;
      // Importante: imposta una variabile specifica per ogni piattaforma per evitare interferenze
      _platformDescriptionLengths[platform] = 0; // Reset counter temporaneamente
    });

    try {
      // Update UI to show loading state
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Generazione descrizione in corso...'),
          duration: Duration(seconds: 1),
        ),
      );
      
      final response = await http.post(
        Uri.parse('https://api.openai.com/v1/chat/completions'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $_apiKey',
        },
        body: jsonEncode({
          'model': 'gpt-4o-mini',
          'messages': [
            {
              'role': 'user',
              'content': 'Scrivi una descrizione per ${platform} a partire da queste informazioni: ${_platformPromptControllers[platform]?.text}. '
                  'La risposta deve essere ben formattata e non superare ${_platformChatGPTLimits[platform]} caratteri. '
                  'Se la piattaforma è Twitter includi hashtag pertinenti. '
                  'Non usare frasi con "scopri", "esplora", "unisciti a noi" o simili. Usa emoji in formato leggibile.',
            }
          ],
          'max_tokens': _maxTokens,
          'temperature': 0.7,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        String generatedText = data['choices'][0]['message']['content'];
        
        // Clean up any potential encoding issues
        generatedText = generatedText
            .replaceAll(RegExp(r'\\u[0-9a-fA-F]{4}'), '') // Remove broken unicode
            .replaceAll(RegExp(r'[^\x00-\x7F]+'), '') // Remove non-ASCII chars
            .replaceAll(RegExp(r'\s+'), ' ') // Normalize whitespace
            .trim();
        
        setState(() {
          // Use platform-specific controller
          if (_platformDescriptionControllers[platform] != null) {
            _platformDescriptionControllers[platform]!.text = generatedText;
            _platformDescriptionLengths[platform] = generatedText.length;
          }
        });
      } else {
        throw Exception('Failed to generate description: ${response.statusCode}');
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error generating description: ${e.toString()}')),
      );
    } finally {
      setState(() {
        _isGeneratingDescription = false;
      });
    }
  }

  Widget _buildDescriptionInput() {
    final theme = Theme.of(context);
    return AnimatedCrossFade(
      duration: const Duration(milliseconds: 300),
      crossFadeState: _useChatGPT ? CrossFadeState.showSecond : CrossFadeState.showFirst,
      firstChild: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.05),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: TextField(
          controller: _descriptionController,
          maxLines: 4,
          textInputAction: TextInputAction.done,
          decoration: InputDecoration(
            hintText: 'Write a description for your video...',
            filled: true,
            fillColor: theme.colorScheme.surface,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(16),
              borderSide: BorderSide(
                color: theme.colorScheme.primary.withOpacity(0.2),
              ),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(16),
              borderSide: BorderSide(
                color: theme.colorScheme.primary.withOpacity(0.2),
              ),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(16),
              borderSide: BorderSide(
                color: theme.colorScheme.primary,
              ),
            ),
          ),
        ),
      ),
      secondChild: Column(
        children: [
          Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(16),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: TextField(
              controller: _promptController,
              decoration: InputDecoration(
                hintText: 'Write the topics of your video...',
                filled: true,
                fillColor: theme.colorScheme.surface,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                ),
                suffixIcon: IconButton(
                  icon: _isGeneratingDescription 
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.send),
                  onPressed: _isGeneratingDescription ? null : _generateDescription,
                ),
              ),
            ),
          ),
          const SizedBox(height: 12),
          Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(16),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: TextField(
              controller: _descriptionController,
              maxLines: 4,
              readOnly: true,
              decoration: InputDecoration(
                hintText: 'Generated description will appear here...',
                filled: true,
                fillColor: theme.colorScheme.surface,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  // Add refresh method
  Future<void> _refreshPage() async {
    setState(() {
      _videoFile = null;
      _thumbnailPath = null;
      _titleController.clear();
      _descriptionController.clear();
      _promptController.clear();
      _selectedAccounts.clear();
      _uploadStatuses.clear();
      _showCheckmark = false;
      
      // Reset platform specific content flags to default (true = use global content)
      _socialAccounts.keys.forEach((platform) {
        _usePlatformSpecificContent[platform] = true;
        
        // Clear platform specific controllers
        if (_platformTitleControllers.containsKey(platform)) {
          _platformTitleControllers[platform]!.clear();
        }
        if (_platformDescriptionControllers.containsKey(platform)) {
          _platformDescriptionControllers[platform]!.clear();
        }
        if (_platformPromptControllers.containsKey(platform)) {
          _platformPromptControllers[platform]!.clear();
        }
        
        // Reset custom flags
        _useChatGPTforPlatform[platform] = false;
        
        // Reset description length counters
        _platformDescriptionLengths[platform] = 0;
      });
    });
    
    await Future.wait([
      _loadSocialAccounts(),
    ]);
    
    // Show success notification
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              Icon(Icons.check_circle, color: Colors.white),
              SizedBox(width: 8),
              Text('Page refreshed successfully'),
            ],
          ),
          backgroundColor: Colors.green,
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
          duration: Duration(seconds: 2),
        ),
      );
    }
  }

  // Add confirmation dialog method
  Future<void> _showRefreshConfirmation() async {
    final theme = Theme.of(context);
    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20),
          ),
          title: Row(
            children: [
              Icon(Icons.warning_amber_rounded, color: Colors.orange),
              SizedBox(width: 8),
              Text(
                'Confirm Refresh',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'This action will:',
                style: TextStyle(
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(height: 8),
              Row(
                children: [
                  Icon(Icons.clear, size: 16, color: Colors.grey),
                  SizedBox(width: 8),
                  Text('Clear selected video'),
                ],
              ),
              SizedBox(height: 4),
              Row(
                children: [
                  Icon(Icons.clear, size: 16, color: Colors.grey),
                  SizedBox(width: 8),
                  Text('Clear all descriptions (general and platform-specific)'),
                ],
              ),
              SizedBox(height: 4),
              Row(
                children: [
                  Icon(Icons.clear, size: 16, color: Colors.grey),
                  SizedBox(width: 8),
                  Text('Deselect all accounts'),
                ],
              ),
              SizedBox(height: 4),
              Row(
                children: [
                  Icon(Icons.refresh, size: 16, color: Colors.grey),
                  SizedBox(width: 8),
                  Text('Reset all custom settings'),
                ],
              ),
              SizedBox(height: 12),
              Text(
                'Are you sure you want to continue?',
                style: TextStyle(
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
          actions: <Widget>[
            TextButton(
              child: Text(
                'Cancel',
                style: TextStyle(
                  color: theme.colorScheme.onSurface,
                ),
              ),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.colorScheme.primary,
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(10),
                ),
              ),
              child: Text('Confirm'),
              onPressed: () {
                Navigator.of(context).pop();
                _refreshPage();
              },
            ),
          ],
        );
      },
    );
  }

  void _onScroll() {
    if (_scrollController.hasClients) {
      final currentPosition = _scrollController.position.pixels;
      
      // Cancel any existing timer
      _scrollDebounceTimer?.cancel();
      
      // Create a new timer
      _scrollDebounceTimer = Timer(const Duration(milliseconds: 100), () {
        if (mounted) {
          // Only update state if the scroll position has changed significantly
          if ((currentPosition - _lastScrollPosition).abs() > 10) {
            setState(() {
              _scrollPosition = currentPosition;
              _lastScrollPosition = currentPosition;
              _showStickyButton = currentPosition > 100;
            });
          }
        }
      });
    }
  }

  @override
  void dispose() {
    // Disporre dei controller specifici per piattaforma
    _platformTitleControllers.forEach((_, controller) => controller.dispose());
    _platformDescriptionControllers.forEach((_, controller) => controller.dispose());
    _platformPromptControllers.forEach((_, controller) => controller.dispose());
    _scrollDebounceTimer?.cancel();
    _scrollController.dispose();
    _titleController.dispose();
    _descriptionController.dispose();
    _promptController.dispose();
    
    // Disponi il controller del video
    if (_videoPlayerController != null) {
      _videoPlayerController!.pause();
      _videoPlayerController!.dispose();
      _videoPlayerController = null;
    }
    
    super.dispose();
  }

  // Inizializza il controller del video
  void _initializeVideoPlayer(File videoFile) {
    // Disponi il controller precedente se esiste
    _videoPlayerController?.dispose();
    
    // Crea un nuovo controller
    _videoPlayerController = VideoPlayerController.file(videoFile);
    
    // Inizializza e riproduci il video
    _videoPlayerController!.initialize().then((_) {
      if (mounted) {
        setState(() {
          _isVideoInitialized = true;
        });
        // Loop the video
        _videoPlayerController!.setLooping(true);
        _videoPlayerController!.play();
      }
    });
  }

  // New helper method to show YouTube shorts info dialog
  void _showYouTubeShortsInfoDialog() {
    final theme = Theme.of(context);
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20),
          ),
          title: Row(
            children: [
              Image.asset(
                'assets/loghi/logo_yt.png',
                width: 28,
                height: 28,
                fit: BoxFit.contain,
              ),
              const SizedBox(width: 12),
              const Text(
                'YouTube Video Formats',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'YouTube automatically determines if your video will be classified as a "Short" based on:',
                style: const TextStyle(
                  fontSize: 14,
                  height: 1.4,
                ),
              ),
              const SizedBox(height: 16),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    padding: const EdgeInsets.all(4),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primary.withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      Icons.timer_outlined,
                      size: 14,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Flexible(
                    child: Text(
                      'Duration must be 60 seconds or less',
                      style: const TextStyle(
                        fontSize: 14,
                        height: 1.4,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    padding: const EdgeInsets.all(4),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primary.withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      Icons.crop_portrait,
                      size: 14,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Flexible(
                    child: Text(
                      'Vertical format (9:16 aspect ratio)',
                      style: const TextStyle(
                        fontSize: 14,
                        height: 1.4,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Text(
                'No manual selection is needed. Your video will automatically appear in the appropriate format based on these criteria.',
                style: TextStyle(
                  fontSize: 13,
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                  height: 1.4,
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text(
                'Got it',
                style: TextStyle(
                  color: theme.colorScheme.primary,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      body: Stack(
        children: [
          SafeArea(
            child: SingleChildScrollView(
              controller: _scrollController,
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  GestureDetector(
                    onTap: _pickMedia,
                    child: Container(
                      height: MediaQuery.of(context).size.height * 0.35,
                      decoration: BoxDecoration(
                        color: theme.colorScheme.surface,
                        borderRadius: BorderRadius.circular(20),
                        border: Border.all(
                          color: theme.colorScheme.primary.withOpacity(0.4),
                          width: 2,
                        ),
                      ),
                      child: _videoFile == null
                          ? Center(
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Icon(
                                    Icons.cloud_upload_outlined,
                                    size: 48,
                                    color: theme.colorScheme.primary,
                                  ),
                                  const SizedBox(height: 12),
                                  Text(
                                    'Tap to select media',
                                    style: theme.textTheme.titleMedium?.copyWith(
                                      color: theme.colorScheme.primary,
                                    ),
                                  ),
                                  const SizedBox(height: 8),
                                  Text(
                                    'Video: MP4, MOV • Images: JPG, PNG',
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                                    ),
                                  ),
                                ],
                              ),
                            )
                          : Center(
                              child: Stack(
                                children: [
                                  if (_isImageFile)
                                    Image.file(
                                      _videoFile!,
                                      fit: BoxFit.contain,
                                    )
                                  else if (_isVideoInitialized && _videoPlayerController != null)
                                    AspectRatio(
                                      aspectRatio: _videoPlayerController!.value.aspectRatio,
                                      child: VideoPlayer(_videoPlayerController!),
                                    )
                                  else
                                    const CircularProgressIndicator(),
                                    
                                  if (_showCheckmark)
                                    Positioned(
                                      top: 8,
                                      right: 8,
                                      child: GestureDetector(
                                        onTap: () {
                                          setState(() {
                                            if (_videoPlayerController != null) {
                                              _videoPlayerController!.pause();
                                              _videoPlayerController!.dispose();
                                              _videoPlayerController = null;
                                            }
                                            _videoFile = null;
                                            _showCheckmark = false;
                                            _isImageFile = false;
                                            _isVideoInitialized = false;
                                          });
                                        },
                                        child: Container(
                                          padding: const EdgeInsets.all(4),
                                          decoration: BoxDecoration(
                                            color: Colors.black.withOpacity(0.6),
                                            shape: BoxShape.circle,
                                          ),
                                          child: const Icon(
                                            Icons.close,
                                            color: Colors.white,
                                            size: 20,
                                          ),
                                        ),
                                      ),
                                    ),
                                ],
                              ),
                            ),
                    ),
                  ),
                  
                  const SizedBox(height: 24),
                  Text(
                    'Video Title',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.onSurface,
                    ),
                  ),
                  const SizedBox(height: 8),
                  TextField(
                    controller: _titleController,
                    decoration: InputDecoration(
                      hintText: 'Enter video title...',
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                  ),
                  
                  const SizedBox(height: 16),
                  Text(
                    'Description',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.onSurface,
                    ),
                  ),
                  const SizedBox(height: 8),
                  TextField(
                    controller: _descriptionController,
                    maxLines: 3,
                    decoration: InputDecoration(
                      hintText: 'Enter video description...',
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                  ),
                  
                  const SizedBox(height: 24),
                  Text(
                    'Select Social Accounts',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.onSurface,
                    ),
                  ),
                  const SizedBox(height: 16),
                  
                  ..._socialAccounts.entries.map((entry) {
                    final platform = entry.key;
                    final accounts = entry.value;
                    
                    if (accounts.isEmpty) {
                      return const SizedBox.shrink();
                    }
                    
                    return Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Padding(
                          padding: const EdgeInsets.only(bottom: 8),
                          child: Row(
                            children: [
                              Image.asset(
                                _platformLogos[platform] ?? '',
                                width: 24,
                                height: 24,
                              ),
                              const SizedBox(width: 8),
                              Text(
                                platform,
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                  fontSize: 16,
                                ),
                              ),
                            ],
                          ),
                        ),
                        ...accounts.map((account) {
                          final accountId = account['id'] as String? ?? '';
                          final isSelected = _selectedAccounts[platform]?.contains(accountId) ?? false;
                          final username = account['username'] as String? ?? 'Unknown';
                          final displayName = account['display_name'] as String? ?? username;
                          final followersCount = account['followers_count'] as String? ?? '0';
                          
                          return ListTile(
                            leading: _buildAccountProfileImage(account['profile_image_url'] as String?, username, theme),
                            title: Text(displayName),
                            subtitle: Text('@$username · $followersCount followers'),
                            trailing: Checkbox(
                              value: isSelected,
                              onChanged: (_) => _toggleAccount(platform, accountId),
                            ),
                            onTap: () => _toggleAccount(platform, accountId),
                          );
                        }).toList(),
                      ],
                    );
                  }).toList(),

                  const SizedBox(height: 20),
                  _buildUploadStatus(),
                ],
              ),
            ),
          ),
          Positioned(
            left: 0,
            right: 0,
            bottom: 0,
            child: _buildStickyCTA(),
          ),
        ],
      ),
    );
  }

  Widget _buildUploadStatus() {
    if (_uploadStatuses.isEmpty) return const SizedBox.shrink();
    final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Upload Status',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          ..._uploadStatuses.entries.map((entry) {
            final status = entry.value;
            return Container(
              margin: const EdgeInsets.only(bottom: 8),
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.surfaceVariant,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: theme.colorScheme.primary.withOpacity(0.2),
                ),
              ),
              child: Row(
                children: [
                  Image.asset(
                    _platformLogos[status.platform] ?? '',
                    width: 32,
                    height: 32,
                    fit: BoxFit.contain,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          status.platform,
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                        if (status.error != null)
                          Text(
                            status.error!,
                            style: TextStyle(
                              color: Colors.red[700],
                              fontSize: 12,
                            ),
                          ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 12),
                  if (status.state == UploadState.uploading)
                    SizedBox(
                      width: 60,
                      child: LinearProgressIndicator(
                        value: status.progress,
                        backgroundColor: theme.colorScheme.surfaceVariant,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          theme.colorScheme.primary,
                        ),
                      ),
                    )
                  else
                    Icon(
                      status.state == UploadState.completed
                          ? Icons.check_circle
                          : status.state == UploadState.error
                              ? Icons.error
                              : Icons.hourglass_empty,
                      color: status.state == UploadState.completed
                          ? Colors.green
                          : status.state == UploadState.error
                              ? Colors.red
                              : Colors.grey,
                    ),
                ],
              ),
            );
          }).toList(),
        ],
      ),
    );
  }

  Widget _buildStickyCTA() {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return GestureDetector(
      onVerticalDragUpdate: (details) {
        if (details.primaryDelta! < 0) {
          // Scrolling up
          setState(() {
            _isMenuExpanded = true;
          });
        } else if (details.primaryDelta! > 0) {
          // Scrolling down
          setState(() {
            _isMenuExpanded = false;
          });
        }
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 300),
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: isDark ? Colors.grey[900] : Colors.white,
          borderRadius: const BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, -4),
            ),
          ],
        ),
        child: SafeArea(
          top: false,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              GestureDetector(
                onTap: () {
                  setState(() {
                    _isMenuExpanded = !_isMenuExpanded;
                  });
                },
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 300),
                  padding: const EdgeInsets.symmetric(vertical: 4),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      AnimatedRotation(
                        duration: const Duration(milliseconds: 300),
                        turns: _isMenuExpanded ? 0.5 : 0,
                        child: Icon(
                          Icons.keyboard_arrow_up,
                          color: isDark ? Colors.white : Colors.black87,
                          size: 20,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              AnimatedCrossFade(
                duration: const Duration(milliseconds: 300),
                firstChild: const SizedBox.shrink(),
                secondChild: Column(
                  children: [
                    // Credit display
                    Container(
                      margin: const EdgeInsets.only(bottom: 12),
                      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.primary.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.account_balance_wallet,
                            size: 16,
                            color: theme.colorScheme.primary,
                          ),
                          const SizedBox(width: 8),
                          Text(
                            'Available Credits: $_userCredits (Cost: 250)',
                            style: TextStyle(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.bold,
                              fontSize: 14,
                            ),
                          ),
                        ],
                      ),
                    ),
                    
                    Row(
                      children: [
                        Expanded(
                          child: ElevatedButton(
                            onPressed: _userCredits < 250 || _isUploading
                                ? null  // Disable if not enough credits
                                : () => _validateAndProceed(false),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: theme.colorScheme.primary,
                              foregroundColor: Colors.white,
                              padding: const EdgeInsets.symmetric(vertical: 16),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              disabledBackgroundColor: Colors.grey,
                            ),
                            child: _isUploading
                                ? const SizedBox(
                                    height: 20,
                                    width: 20,
                                    child: CircularProgressIndicator(
                                      strokeWidth: 2,
                                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                    ),
                                  )
                                : Text(_userCredits < 250 
                                    ? 'Not Enough Credits' 
                                    : 'Upload Video'),
                          ),
                        ),
                        if (widget.draftData == null) ...[
                          const SizedBox(width: 12),
                          Expanded(
                            child: ElevatedButton(
                              onPressed: _isUploading ? null : _saveAsDraft,
                              style: ElevatedButton.styleFrom(
                                backgroundColor: theme.colorScheme.surfaceVariant,
                                foregroundColor: theme.colorScheme.onSurface,
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(12),
                                ),
                              ),
                              child: _isUploading
                                  ? const SizedBox(
                                      height: 20,
                                      width: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                      ),
                                    )
                                  : const Text('Save as Draft'),
                            ),
                          ),
                        ],
                      ],
                    ),
                    const SizedBox(height: 12),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: _userCredits < 250 || _isUploading
                            ? null  // Disable if not enough credits
                            : () => _validateAndProceed(true),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: theme.colorScheme.primary,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                          disabledBackgroundColor: Colors.grey,
                        ),
                        child: Text(
                          _userCredits < 250 
                              ? 'Not Enough Credits'
                              : 'Programma post',
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                crossFadeState: _isMenuExpanded ? CrossFadeState.showSecond : CrossFadeState.showFirst,
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildContentTypeButton(ThemeData theme, String type, IconData icon, String accountId) {
    // Verifica che l'accountId sia non vuoto
    if (accountId.isEmpty) {
      return const SizedBox.shrink(); // Non mostrare il pulsante se l'ID non è valido
    }
    
    // Controlla se questo tipo è selezionato per questo specifico account
    bool isSelected = _instagramContentType[accountId] == type;
    
    // Se non c'è un tipo selezionato per questo account e questo è il tipo "Post", consideralo selezionato di default
    if (_instagramContentType[accountId] == null && type == 'Post') {
      isSelected = true;
    }
    
    final bool isPressed = _pressedButton == "$accountId:$type";
    
    return GestureDetector(
      onTapDown: (_) {
        setState(() {
          _pressedButton = "$accountId:$type";
        });
      },
      onTapUp: (_) {
        setState(() {
          _pressedButton = null;
          // Imposta il tipo di contenuto solo per l'account specifico
          _instagramContentType[accountId] = type;
        });
      },
      onTapCancel: () {
        setState(() {
          _pressedButton = null;
        });
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.symmetric(horizontal: 2),
        transform: isPressed ? (Matrix4.identity()..scale(0.95)) : Matrix4.identity(),
        child: Material(
          color: Colors.transparent,
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 250),
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
            decoration: BoxDecoration(
              color: isSelected
                  ? theme.colorScheme.primary
                  : (isPressed ? theme.colorScheme.primary.withOpacity(0.1) : theme.colorScheme.surface),
              borderRadius: BorderRadius.circular(10),
              boxShadow: [
                if (isSelected || isPressed)
                  BoxShadow(
                    color: theme.colorScheme.primary.withOpacity(0.3),
                    blurRadius: 4,
                    spreadRadius: 0,
                    offset: const Offset(0, 1),
                  )
              ],
              border: Border.all(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.colorScheme.onSurface.withOpacity(0.1),
                width: isSelected ? 1.5 : 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  icon,
                  size: 14,
                  color: isSelected ? Colors.white : theme.colorScheme.primary,
                ),
                const SizedBox(width: 4),
                Text(
                  type,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: isSelected ? FontWeight.bold : FontWeight.w500,
                    color: isSelected ? Colors.white : theme.colorScheme.onSurface,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Add these helper methods at an appropriate place in the class
  bool _platformSupportsTitle(String platform) {
    // Add platforms that support title
    return ['YouTube', 'TikTok', 'Facebook'].contains(platform);
  }
  
  bool _platformSupportsDescription(String platform) {
    // All platforms support description but with different length limits
    return true;
  }
  
  String _getPlatformInstructions(String platform) {
    switch (platform) {
      case 'YouTube':
        return 'YouTube automatically determines if your video will be classified as a "Short" based on:\n\n• Duration must be 60 seconds or less\n• Vertical format (9:16 aspect ratio)\n\nNo manual selection is needed. Your video will automatically appear in the appropriate format based on these criteria.';
      case 'TikTok':
        return 'TikTok supports short-form videos with:\n\n• Maximum duration: 3 minutes\n• Recommended hashtags: 3-5 per post\n• Music and effects boost engagement\n• Text overlays need to be concise';
      case 'Instagram':
        return 'Instagram supports several post types:\n\n• Post: Square or landscape image/video\n• Reels: Short vertical video (up to 90 seconds)\n• Story: 15-second vertical format\n\nYou can select content type for each account individually.';
      case 'Facebook':
        return 'Facebook supports multiple video formats:\n\n• News Feed videos: 1:1 or 16:9 format\n• Facebook Watch: Longer content preferred\n• Stories: 15-second vertical format\n\nTag relevant pages to increase reach.';
      case 'Twitter':
        return 'Twitter (X) video requirements:\n\n• Maximum length: 2 minutes 20 seconds\n• Maximum file size: 512MB\n• Character limit: 280 characters\n\nUse hashtags strategically to improve visibility.';
      case 'Threads':
        return 'Threads is similar to Twitter with:\n\n• Character limit: 500 characters\n• Conversational tone works best\n• Videos up to 5 minutes\n• Connected to Instagram audiences';
      default:
        return 'Select the accounts you want to use to publish your content.';
    }
  }

  // Helper method per ottenere il colore della barra di avanzamento in base alla percentuale
  Color _getProgressColor(double percentage, ThemeData theme) {
    if (percentage < 0.7) {
      return theme.colorScheme.primary;
    } else if (percentage < 0.9) {
      return Colors.orange;
    } else {
      return theme.colorScheme.error;
    }
  }

  // Add a method to handle profile image display with proper error handling
  Widget _buildAccountProfileImage(String? profileImageUrl, String username, ThemeData theme) {
    return CircleAvatar(
      radius: 22,
      backgroundColor: theme.colorScheme.surfaceVariant,
      child: profileImageUrl?.isNotEmpty == true
          ? ClipOval(
              child: Image.network(
                profileImageUrl!,
                width: 44,
                height: 44,
                fit: BoxFit.cover,
                errorBuilder: (context, error, stackTrace) {
                  // Return fallback with first letter when image fails to load
                  return Text(
                    username.isNotEmpty ? username[0].toUpperCase() : '?',
                    style: TextStyle(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.bold,
                    ),
                  );
                },
              ),
            )
          : Text(
              username.isNotEmpty ? username[0].toUpperCase() : '?',
              style: TextStyle(
                color: theme.colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
    );
  }

  // Nuovo metodo per caricare file su Cloudflare R2 tramite Worker
  Future<String?> _uploadToCloudflare(File file, {bool isImage = false}) async {
    try {
      print('Starting upload to Cloudflare R2...');

      // Ottieni il token da Firebase
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception('User not authenticated');
      
      // Ottieni il token ID da Firebase
      final idToken = await currentUser.getIdToken();
      if (idToken == null) throw Exception('Failed to get Firebase ID token');

      // 1. Richiedi un URL firmato dal worker Cloudflare
      final String fileName = file.path.split('/').last;
      final String fileExtension = fileName.split('.').last.toLowerCase();

      // Controlla se è un'immagine o un video basandosi sull'estensione
      final String contentType = isImage || 
                                ['jpg', 'jpeg', 'png', 'gif', 'webp'].contains(fileExtension)
                                ? 'image/$fileExtension' 
                                : 'video/$fileExtension';
      
      print('Requesting signed URL for ${isImage ? "image" : "video"}: $fileName');
      
      // Fai la richiesta al worker per ottenere un URL firmato per il caricamento
      final response = await http.post(
        Uri.parse('https://plain-star-669f.giuseppemaria162.workers.dev'),
        headers: {
          'Authorization': 'Bearer $idToken',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'fileName': fileName,
          'operation': 'write', // Operazione di scrittura per caricare file
        }),
      );

      if (response.statusCode != 200) {
        throw Exception('Failed to get signed URL: ${response.body}');
      }

      // Estrai l'URL firmato dalla risposta
      final signedUrlData = jsonDecode(response.body);
      final String signedUrl = signedUrlData['signedUrl'];
      
      if (signedUrl.isEmpty) {
        throw Exception('Received empty signed URL from worker');
      }
      
      print('Received signed URL from Cloudflare: $signedUrl');
      
      // 2. Carica il file usando l'URL firmato
      final uploadResponse = await http.put(
        Uri.parse(signedUrl),
        headers: {
          'Content-Type': contentType,
        },
        body: await file.readAsBytes(),
      );

      if (uploadResponse.statusCode >= 200 && uploadResponse.statusCode < 300) {
        print('Successfully uploaded file to Cloudflare R2: $fileName');
        
        // Ritorna l'URL pubblico per accedere al file
        final publicUrl = 'https://3cd9209da4d0a20e311d486fc37f1a71.r2.cloudflarestorage.com/videos/$fileName';
        return publicUrl;
      } else {
        throw Exception('Failed to upload file to Cloudflare R2: ${uploadResponse.statusCode}, ${uploadResponse.body}');
      }
    } catch (e) {
      print('Error uploading to Cloudflare R2: $e');
      rethrow;
    }
  }

  // Visualizza l'immagine del profilo dell'account
  Widget _buildAccountProfileImage(String? imageUrl) {
    if (imageUrl != null && imageUrl.isNotEmpty) {
      return ClipRRect(
        borderRadius: BorderRadius.circular(20),
        child: Image.network(
          imageUrl,
          width: 40,
          height: 40,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            return _buildDefaultProfileImage();
          },
          loadingBuilder: (context, child, loadingProgress) {
            if (loadingProgress == null) return child;
            return _buildDefaultProfileImage();
          },
        ),
      );
    }
    return _buildDefaultProfileImage();
  }
  
  Widget _buildDefaultProfileImage() {
    return Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        color: Colors.grey[300],
        borderRadius: BorderRadius.circular(20),
      ),
      child: Icon(
        Icons.person,
        color: Colors.grey[600],
        size: 24,
      ),
    );
  }
} 